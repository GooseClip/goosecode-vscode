// @generated by protobuf-ts 2.11.0 with parameter server_generic,client_none
// @generated from protobuf file "gooseclip/goosecode/ide/v1/api.proto" (package "gooseclip.goosecode.ide.v1", syntax proto3)
// tslint:disable
import { PushResponse } from "./push";
import { PushRequest } from "./push";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { LocationWithContext } from "./vscode";
import { DocumentSymbol } from "./vscode";
import { Location } from "./vscode";
import { FileContext } from "./files";
import { VersionControlInfo } from "./version_control";
/**
 * //////////////////////////////////////////////////////////////////////////////////////////
 * Context
 * //////////////////////////////////////////////////////////////////////////////////////////
 *
 * @generated from protobuf message gooseclip.goosecode.ide.v1.Context
 */
export interface Context {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.VersionControlInfo version_control_info = 1
     */
    versionControlInfo?: VersionControlInfo;
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Get Files
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.GetFilesRequest
 */
export interface GetFilesRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: repeated string file_paths = 2
     */
    filePaths: string[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.GetFilesResponse
 */
export interface GetFilesResponse {
    /**
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.FileContext file_context = 1
     */
    fileContext: FileContext[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ListFilesRequest
 */
export interface ListFilesRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: repeated string excluded_dir = 2
     */
    excludedDir: string[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ListFilesResponse
 */
export interface ListFilesResponse {
    /**
     * @generated from protobuf field: repeated string file_paths = 1
     */
    filePaths: string[];
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Selection
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.SelectRequest
 */
export interface SelectRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 2
     */
    location?: Location;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.SelectResponse
 */
export interface SelectResponse {
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Navigation
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.OpenFilesRequest
 */
export interface OpenFilesRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: repeated string file_paths = 2
     */
    filePaths: string[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.GoToDefinitionRequest
 */
export interface GoToDefinitionRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 2
     */
    location?: Location;
    /**
     * @generated from protobuf field: bool select = 3
     */
    select: boolean;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.NavigateRequest
 */
export interface NavigateRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.NavigateType type = 2
     */
    type: NavigateType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "goToDefinition";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.GoToDefinitionRequest go_to_definition = 5
         */
        goToDefinition: GoToDefinitionRequest;
    } | {
        oneofKind: "openFiles";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.OpenFilesRequest open_files = 6
         */
        openFiles: OpenFilesRequest;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.NavigateResponse
 */
export interface NavigateResponse {
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Search
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.FindPattern
 */
export interface FindPattern {
    /**
     * @generated from protobuf field: string search_pattern = 1
     */
    searchPattern: string;
    /**
     * @generated from protobuf field: repeated string included_files = 2
     */
    includedFiles: string[];
    /**
     * @generated from protobuf field: repeated string excluded_files = 3
     */
    excludedFiles: string[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.FindPatternResult
 */
export interface FindPatternResult {
    /**
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.Location locations = 1
     */
    locations: Location[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.FindUses
 */
export interface FindUses {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 1
     */
    location?: Location;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.FindUsesResult
 */
export interface FindUsesResult {
    /**
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.Location locations = 1
     */
    locations: Location[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.SearchRequest
 */
export interface SearchRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.SearchType type = 2
     */
    type: SearchType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "pattern";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.FindPattern pattern = 5
         */
        pattern: FindPattern;
    } | {
        oneofKind: "uses";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.FindUses uses = 6
         */
        uses: FindUses;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.SearchResponse
 */
export interface SearchResponse {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.SearchType type = 1
     */
    type: SearchType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "pattern";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.FindPatternResult pattern = 5
         */
        pattern: FindPatternResult;
    } | {
        oneofKind: "uses";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.FindUsesResult uses = 6
         */
        uses: FindUsesResult;
    } | {
        oneofKind: undefined;
    };
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Probing
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.DescribeRange
 */
export interface DescribeRange {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 1
     */
    location?: Location;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.DescribeRangeResult
 */
export interface DescribeRangeResult {
    /**
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.DocumentSymbol symbols = 1
     */
    symbols: DocumentSymbol[];
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ProbeRequest
 */
export interface ProbeRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.ProbeType type = 2
     */
    type: ProbeType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "describeRange";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.DescribeRange describe_range = 5
         */
        describeRange: DescribeRange;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ProbeResponse
 */
export interface ProbeResponse {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.ProbeType type = 1
     */
    type: ProbeType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "describeRange";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.DescribeRangeResult describe_range = 5
         */
        describeRange: DescribeRangeResult;
    } | {
        oneofKind: undefined;
    };
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Symbol Resolution
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ResolveSymbolRequest
 */
export interface ResolveSymbolRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 2
     */
    location?: Location;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.ResolveSymbolResponse
 */
export interface ResolveSymbolResponse {
    /**
     * The definition location of the symbol
     *
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.LocationWithContext definition = 1
     */
    definition?: LocationWithContext;
    /**
     * File contexts for both the source and definition files
     *
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.FileContext file_contexts = 2
     */
    fileContexts: FileContext[];
    /**
     * Whether a definition was found
     *
     * @generated from protobuf field: bool found = 3
     */
    found: boolean;
    /**
     * Whether the clicked position is on a definition (vs a usage/reference)
     * If true, references will be populated instead of definition
     *
     * @generated from protobuf field: bool is_on_definition = 4
     */
    isOnDefinition: boolean;
    /**
     * References to the symbol (populated when is_on_definition is true)
     *
     * @generated from protobuf field: repeated gooseclip.goosecode.ide.v1.LocationWithContext references = 5
     */
    references: LocationWithContext[];
    /**
     * The word range and context at the clicked position (for the "from" location)
     *
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.LocationWithContext from_context = 6
     */
    fromContext?: LocationWithContext;
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Refactoring
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.Rename
 */
export interface Rename {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Location location = 1
     */
    location?: Location;
    /**
     * @generated from protobuf field: string new_name = 2
     */
    newName: string;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.RefactorRequest
 */
export interface RefactorRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.RefactorType type = 2
     */
    type: RefactorType;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "rename";
        /**
         * @generated from protobuf field: gooseclip.goosecode.ide.v1.Rename rename = 5
         */
        rename: Rename;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.RefactorResponse
 */
export interface RefactorResponse {
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Version Control
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.VersionControlDetailsRequest
 */
export interface VersionControlDetailsRequest {
    /**
     * @generated from protobuf field: gooseclip.goosecode.ide.v1.Context context = 1
     */
    context?: Context;
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.VersionControlDetailsResponse
 */
export interface VersionControlDetailsResponse {
    /**
     * @generated from protobuf field: string owner = 1
     */
    owner: string;
    /**
     * @generated from protobuf field: string repository = 2
     */
    repository: string;
    /**
     * @generated from protobuf field: string branch = 3
     */
    branch: string;
    /**
     * @generated from protobuf field: string commit = 4
     */
    commit: string;
}
// //////////////////////////////////////////////////////////////////////////////////////////
// Linting
// //////////////////////////////////////////////////////////////////////////////////////////

/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.LintRequest
 */
export interface LintRequest {
}
/**
 * @generated from protobuf message gooseclip.goosecode.ide.v1.LintResponse
 */
export interface LintResponse {
}
/**
 * @generated from protobuf enum gooseclip.goosecode.ide.v1.NavigateType
 */
export enum NavigateType {
    /**
     * @generated from protobuf enum value: NAVIGATE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: NAVIGATE_TYPE_GO_TO_DEFINITION = 1;
     */
    GO_TO_DEFINITION = 1,
    /**
     * @generated from protobuf enum value: NAVIGATE_TYPE_OPEN_FILE = 2;
     */
    OPEN_FILE = 2
}
/**
 * @generated from protobuf enum gooseclip.goosecode.ide.v1.SearchType
 */
export enum SearchType {
    /**
     * @generated from protobuf enum value: SEARCH_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SEARCH_TYPE_PATTERN = 1;
     */
    PATTERN = 1,
    /**
     * @generated from protobuf enum value: SEARCH_TYPE_USES = 2;
     */
    USES = 2
}
/**
 * @generated from protobuf enum gooseclip.goosecode.ide.v1.ProbeType
 */
export enum ProbeType {
    /**
     * @generated from protobuf enum value: PROBE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PROBE_TYPE_DESCRIBE_RANGE = 1;
     */
    DESCRIBE_RANGE = 1
}
/**
 * @generated from protobuf enum gooseclip.goosecode.ide.v1.RefactorType
 */
export enum RefactorType {
    /**
     * @generated from protobuf enum value: REFACTOR_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: REFACTOR_TYPE_RENAME = 1;
     */
    RENAME = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class Context$Type extends MessageType<Context> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.Context", [
            { no: 1, name: "version_control_info", kind: "message", T: () => VersionControlInfo }
        ]);
    }
    create(value?: PartialMessage<Context>): Context {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Context>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Context): Context {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.VersionControlInfo version_control_info */ 1:
                    message.versionControlInfo = VersionControlInfo.internalBinaryRead(reader, reader.uint32(), options, message.versionControlInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Context, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.VersionControlInfo version_control_info = 1; */
        if (message.versionControlInfo)
            VersionControlInfo.internalBinaryWrite(message.versionControlInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.Context
 */
export const Context = new Context$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFilesRequest$Type extends MessageType<GetFilesRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.GetFilesRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "file_paths", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetFilesRequest>): GetFilesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filePaths = [];
        if (value !== undefined)
            reflectionMergePartial<GetFilesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFilesRequest): GetFilesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated string file_paths */ 2:
                    message.filePaths.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFilesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string file_paths = 2; */
        for (let i = 0; i < message.filePaths.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.filePaths[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.GetFilesRequest
 */
export const GetFilesRequest = new GetFilesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFilesResponse$Type extends MessageType<GetFilesResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.GetFilesResponse", [
            { no: 1, name: "file_context", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileContext, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<GetFilesResponse>): GetFilesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileContext = [];
        if (value !== undefined)
            reflectionMergePartial<GetFilesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFilesResponse): GetFilesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseclip.goosecode.ide.v1.FileContext file_context */ 1:
                    message.fileContext.push(FileContext.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFilesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseclip.goosecode.ide.v1.FileContext file_context = 1; */
        for (let i = 0; i < message.fileContext.length; i++)
            FileContext.internalBinaryWrite(message.fileContext[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.GetFilesResponse
 */
export const GetFilesResponse = new GetFilesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFilesRequest$Type extends MessageType<ListFilesRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ListFilesRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "excluded_dir", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFilesRequest>): ListFilesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.excludedDir = [];
        if (value !== undefined)
            reflectionMergePartial<ListFilesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFilesRequest): ListFilesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated string excluded_dir */ 2:
                    message.excludedDir.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFilesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string excluded_dir = 2; */
        for (let i = 0; i < message.excludedDir.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.excludedDir[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ListFilesRequest
 */
export const ListFilesRequest = new ListFilesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFilesResponse$Type extends MessageType<ListFilesResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ListFilesResponse", [
            { no: 1, name: "file_paths", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFilesResponse>): ListFilesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filePaths = [];
        if (value !== undefined)
            reflectionMergePartial<ListFilesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFilesResponse): ListFilesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string file_paths */ 1:
                    message.filePaths.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFilesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string file_paths = 1; */
        for (let i = 0; i < message.filePaths.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.filePaths[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ListFilesResponse
 */
export const ListFilesResponse = new ListFilesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectRequest$Type extends MessageType<SelectRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.SelectRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<SelectRequest>): SelectRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SelectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectRequest): SelectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.Location location */ 2:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.Location location = 2; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.SelectRequest
 */
export const SelectRequest = new SelectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelectResponse$Type extends MessageType<SelectResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.SelectResponse", []);
    }
    create(value?: PartialMessage<SelectResponse>): SelectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SelectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelectResponse): SelectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.SelectResponse
 */
export const SelectResponse = new SelectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenFilesRequest$Type extends MessageType<OpenFilesRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.OpenFilesRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "file_paths", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { repeated: { minItems: "1" } } } }
        ]);
    }
    create(value?: PartialMessage<OpenFilesRequest>): OpenFilesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filePaths = [];
        if (value !== undefined)
            reflectionMergePartial<OpenFilesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenFilesRequest): OpenFilesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated string file_paths */ 2:
                    message.filePaths.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenFilesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string file_paths = 2; */
        for (let i = 0; i < message.filePaths.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.filePaths[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.OpenFilesRequest
 */
export const OpenFilesRequest = new OpenFilesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GoToDefinitionRequest$Type extends MessageType<GoToDefinitionRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.GoToDefinitionRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } },
            { no: 3, name: "select", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GoToDefinitionRequest>): GoToDefinitionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.select = false;
        if (value !== undefined)
            reflectionMergePartial<GoToDefinitionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GoToDefinitionRequest): GoToDefinitionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.Location location */ 2:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* bool select */ 3:
                    message.select = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GoToDefinitionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.Location location = 2; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool select = 3; */
        if (message.select !== false)
            writer.tag(3, WireType.Varint).bool(message.select);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.GoToDefinitionRequest
 */
export const GoToDefinitionRequest = new GoToDefinitionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NavigateRequest$Type extends MessageType<NavigateRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.NavigateRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.NavigateType", NavigateType, "NAVIGATE_TYPE_"], options: { "buf.validate.field": { required: true, enum: { definedOnly: true } } } },
            { no: 5, name: "go_to_definition", kind: "message", oneof: "data", T: () => GoToDefinitionRequest },
            { no: 6, name: "open_files", kind: "message", oneof: "data", T: () => OpenFilesRequest }
        ]);
    }
    create(value?: PartialMessage<NavigateRequest>): NavigateRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<NavigateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NavigateRequest): NavigateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.NavigateType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.GoToDefinitionRequest go_to_definition */ 5:
                    message.data = {
                        oneofKind: "goToDefinition",
                        goToDefinition: GoToDefinitionRequest.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).goToDefinition)
                    };
                    break;
                case /* gooseclip.goosecode.ide.v1.OpenFilesRequest open_files */ 6:
                    message.data = {
                        oneofKind: "openFiles",
                        openFiles: OpenFilesRequest.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).openFiles)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NavigateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.NavigateType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.GoToDefinitionRequest go_to_definition = 5; */
        if (message.data.oneofKind === "goToDefinition")
            GoToDefinitionRequest.internalBinaryWrite(message.data.goToDefinition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.OpenFilesRequest open_files = 6; */
        if (message.data.oneofKind === "openFiles")
            OpenFilesRequest.internalBinaryWrite(message.data.openFiles, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.NavigateRequest
 */
export const NavigateRequest = new NavigateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NavigateResponse$Type extends MessageType<NavigateResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.NavigateResponse", []);
    }
    create(value?: PartialMessage<NavigateResponse>): NavigateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<NavigateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NavigateResponse): NavigateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NavigateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.NavigateResponse
 */
export const NavigateResponse = new NavigateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindPattern$Type extends MessageType<FindPattern> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.FindPattern", [
            { no: 1, name: "search_pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "included_files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "excluded_files", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FindPattern>): FindPattern {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.searchPattern = "";
        message.includedFiles = [];
        message.excludedFiles = [];
        if (value !== undefined)
            reflectionMergePartial<FindPattern>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindPattern): FindPattern {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string search_pattern */ 1:
                    message.searchPattern = reader.string();
                    break;
                case /* repeated string included_files */ 2:
                    message.includedFiles.push(reader.string());
                    break;
                case /* repeated string excluded_files */ 3:
                    message.excludedFiles.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindPattern, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string search_pattern = 1; */
        if (message.searchPattern !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.searchPattern);
        /* repeated string included_files = 2; */
        for (let i = 0; i < message.includedFiles.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.includedFiles[i]);
        /* repeated string excluded_files = 3; */
        for (let i = 0; i < message.excludedFiles.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.excludedFiles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.FindPattern
 */
export const FindPattern = new FindPattern$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindPatternResult$Type extends MessageType<FindPatternResult> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.FindPatternResult", [
            { no: 1, name: "locations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Location }
        ]);
    }
    create(value?: PartialMessage<FindPatternResult>): FindPatternResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = [];
        if (value !== undefined)
            reflectionMergePartial<FindPatternResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindPatternResult): FindPatternResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseclip.goosecode.ide.v1.Location locations */ 1:
                    message.locations.push(Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindPatternResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseclip.goosecode.ide.v1.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            Location.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.FindPatternResult
 */
export const FindPatternResult = new FindPatternResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindUses$Type extends MessageType<FindUses> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.FindUses", [
            { no: 1, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<FindUses>): FindUses {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FindUses>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindUses): FindUses {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Location location */ 1:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindUses, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Location location = 1; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.FindUses
 */
export const FindUses = new FindUses$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindUsesResult$Type extends MessageType<FindUsesResult> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.FindUsesResult", [
            { no: 1, name: "locations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Location }
        ]);
    }
    create(value?: PartialMessage<FindUsesResult>): FindUsesResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locations = [];
        if (value !== undefined)
            reflectionMergePartial<FindUsesResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindUsesResult): FindUsesResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseclip.goosecode.ide.v1.Location locations */ 1:
                    message.locations.push(Location.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindUsesResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseclip.goosecode.ide.v1.Location locations = 1; */
        for (let i = 0; i < message.locations.length; i++)
            Location.internalBinaryWrite(message.locations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.FindUsesResult
 */
export const FindUsesResult = new FindUsesResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.SearchRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context },
            { no: 2, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.SearchType", SearchType, "SEARCH_TYPE_"] },
            { no: 5, name: "pattern", kind: "message", oneof: "data", T: () => FindPattern },
            { no: 6, name: "uses", kind: "message", oneof: "data", T: () => FindUses }
        ]);
    }
    create(value?: PartialMessage<SearchRequest>): SearchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.SearchType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.FindPattern pattern */ 5:
                    message.data = {
                        oneofKind: "pattern",
                        pattern: FindPattern.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).pattern)
                    };
                    break;
                case /* gooseclip.goosecode.ide.v1.FindUses uses */ 6:
                    message.data = {
                        oneofKind: "uses",
                        uses: FindUses.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).uses)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.SearchType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.FindPattern pattern = 5; */
        if (message.data.oneofKind === "pattern")
            FindPattern.internalBinaryWrite(message.data.pattern, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.FindUses uses = 6; */
        if (message.data.oneofKind === "uses")
            FindUses.internalBinaryWrite(message.data.uses, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.SearchRequest
 */
export const SearchRequest = new SearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchResponse$Type extends MessageType<SearchResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.SearchResponse", [
            { no: 1, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.SearchType", SearchType, "SEARCH_TYPE_"], options: { "buf.validate.field": { required: true, enum: { definedOnly: true } } } },
            { no: 5, name: "pattern", kind: "message", oneof: "data", T: () => FindPatternResult },
            { no: 6, name: "uses", kind: "message", oneof: "data", T: () => FindUsesResult }
        ]);
    }
    create(value?: PartialMessage<SearchResponse>): SearchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SearchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchResponse): SearchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.SearchType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.FindPatternResult pattern */ 5:
                    message.data = {
                        oneofKind: "pattern",
                        pattern: FindPatternResult.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).pattern)
                    };
                    break;
                case /* gooseclip.goosecode.ide.v1.FindUsesResult uses */ 6:
                    message.data = {
                        oneofKind: "uses",
                        uses: FindUsesResult.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).uses)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.SearchType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.FindPatternResult pattern = 5; */
        if (message.data.oneofKind === "pattern")
            FindPatternResult.internalBinaryWrite(message.data.pattern, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.FindUsesResult uses = 6; */
        if (message.data.oneofKind === "uses")
            FindUsesResult.internalBinaryWrite(message.data.uses, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.SearchResponse
 */
export const SearchResponse = new SearchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DescribeRange$Type extends MessageType<DescribeRange> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.DescribeRange", [
            { no: 1, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<DescribeRange>): DescribeRange {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DescribeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DescribeRange): DescribeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Location location */ 1:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DescribeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Location location = 1; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.DescribeRange
 */
export const DescribeRange = new DescribeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DescribeRangeResult$Type extends MessageType<DescribeRangeResult> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.DescribeRangeResult", [
            { no: 1, name: "symbols", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DocumentSymbol }
        ]);
    }
    create(value?: PartialMessage<DescribeRangeResult>): DescribeRangeResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.symbols = [];
        if (value !== undefined)
            reflectionMergePartial<DescribeRangeResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DescribeRangeResult): DescribeRangeResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated gooseclip.goosecode.ide.v1.DocumentSymbol symbols */ 1:
                    message.symbols.push(DocumentSymbol.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DescribeRangeResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated gooseclip.goosecode.ide.v1.DocumentSymbol symbols = 1; */
        for (let i = 0; i < message.symbols.length; i++)
            DocumentSymbol.internalBinaryWrite(message.symbols[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.DescribeRangeResult
 */
export const DescribeRangeResult = new DescribeRangeResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProbeRequest$Type extends MessageType<ProbeRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ProbeRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.ProbeType", ProbeType, "PROBE_TYPE_"], options: { "buf.validate.field": { required: true, enum: { definedOnly: true } } } },
            { no: 5, name: "describe_range", kind: "message", oneof: "data", T: () => DescribeRange }
        ]);
    }
    create(value?: PartialMessage<ProbeRequest>): ProbeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProbeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProbeRequest): ProbeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.ProbeType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.DescribeRange describe_range */ 5:
                    message.data = {
                        oneofKind: "describeRange",
                        describeRange: DescribeRange.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).describeRange)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProbeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.ProbeType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.DescribeRange describe_range = 5; */
        if (message.data.oneofKind === "describeRange")
            DescribeRange.internalBinaryWrite(message.data.describeRange, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ProbeRequest
 */
export const ProbeRequest = new ProbeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProbeResponse$Type extends MessageType<ProbeResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ProbeResponse", [
            { no: 1, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.ProbeType", ProbeType, "PROBE_TYPE_"], options: { "buf.validate.field": { required: true, enum: { definedOnly: true } } } },
            { no: 5, name: "describe_range", kind: "message", oneof: "data", T: () => DescribeRangeResult }
        ]);
    }
    create(value?: PartialMessage<ProbeResponse>): ProbeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ProbeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProbeResponse): ProbeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.ProbeType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.DescribeRangeResult describe_range */ 5:
                    message.data = {
                        oneofKind: "describeRange",
                        describeRange: DescribeRangeResult.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).describeRange)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProbeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.ProbeType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.DescribeRangeResult describe_range = 5; */
        if (message.data.oneofKind === "describeRange")
            DescribeRangeResult.internalBinaryWrite(message.data.describeRange, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ProbeResponse
 */
export const ProbeResponse = new ProbeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveSymbolRequest$Type extends MessageType<ResolveSymbolRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ResolveSymbolRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<ResolveSymbolRequest>): ResolveSymbolRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResolveSymbolRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolveSymbolRequest): ResolveSymbolRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.Location location */ 2:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResolveSymbolRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.Location location = 2; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ResolveSymbolRequest
 */
export const ResolveSymbolRequest = new ResolveSymbolRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResolveSymbolResponse$Type extends MessageType<ResolveSymbolResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.ResolveSymbolResponse", [
            { no: 1, name: "definition", kind: "message", T: () => LocationWithContext },
            { no: 2, name: "file_contexts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileContext },
            { no: 3, name: "found", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "is_on_definition", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "references", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => LocationWithContext },
            { no: 6, name: "from_context", kind: "message", T: () => LocationWithContext }
        ]);
    }
    create(value?: PartialMessage<ResolveSymbolResponse>): ResolveSymbolResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fileContexts = [];
        message.found = false;
        message.isOnDefinition = false;
        message.references = [];
        if (value !== undefined)
            reflectionMergePartial<ResolveSymbolResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResolveSymbolResponse): ResolveSymbolResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.LocationWithContext definition */ 1:
                    message.definition = LocationWithContext.internalBinaryRead(reader, reader.uint32(), options, message.definition);
                    break;
                case /* repeated gooseclip.goosecode.ide.v1.FileContext file_contexts */ 2:
                    message.fileContexts.push(FileContext.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool found */ 3:
                    message.found = reader.bool();
                    break;
                case /* bool is_on_definition */ 4:
                    message.isOnDefinition = reader.bool();
                    break;
                case /* repeated gooseclip.goosecode.ide.v1.LocationWithContext references */ 5:
                    message.references.push(LocationWithContext.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* gooseclip.goosecode.ide.v1.LocationWithContext from_context */ 6:
                    message.fromContext = LocationWithContext.internalBinaryRead(reader, reader.uint32(), options, message.fromContext);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResolveSymbolResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.LocationWithContext definition = 1; */
        if (message.definition)
            LocationWithContext.internalBinaryWrite(message.definition, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated gooseclip.goosecode.ide.v1.FileContext file_contexts = 2; */
        for (let i = 0; i < message.fileContexts.length; i++)
            FileContext.internalBinaryWrite(message.fileContexts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool found = 3; */
        if (message.found !== false)
            writer.tag(3, WireType.Varint).bool(message.found);
        /* bool is_on_definition = 4; */
        if (message.isOnDefinition !== false)
            writer.tag(4, WireType.Varint).bool(message.isOnDefinition);
        /* repeated gooseclip.goosecode.ide.v1.LocationWithContext references = 5; */
        for (let i = 0; i < message.references.length; i++)
            LocationWithContext.internalBinaryWrite(message.references[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.LocationWithContext from_context = 6; */
        if (message.fromContext)
            LocationWithContext.internalBinaryWrite(message.fromContext, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.ResolveSymbolResponse
 */
export const ResolveSymbolResponse = new ResolveSymbolResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rename$Type extends MessageType<Rename> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.Rename", [
            { no: 1, name: "location", kind: "message", T: () => Location, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "new_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<Rename>): Rename {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newName = "";
        if (value !== undefined)
            reflectionMergePartial<Rename>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rename): Rename {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Location location */ 1:
                    message.location = Location.internalBinaryRead(reader, reader.uint32(), options, message.location);
                    break;
                case /* string new_name */ 2:
                    message.newName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rename, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Location location = 1; */
        if (message.location)
            Location.internalBinaryWrite(message.location, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string new_name = 2; */
        if (message.newName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.newName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.Rename
 */
export const Rename = new Rename$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefactorRequest$Type extends MessageType<RefactorRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.RefactorRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "type", kind: "enum", T: () => ["gooseclip.goosecode.ide.v1.RefactorType", RefactorType, "REFACTOR_TYPE_"], options: { "buf.validate.field": { required: true, enum: { definedOnly: true } } } },
            { no: 5, name: "rename", kind: "message", oneof: "data", T: () => Rename }
        ]);
    }
    create(value?: PartialMessage<RefactorRequest>): RefactorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.data = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RefactorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefactorRequest): RefactorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* gooseclip.goosecode.ide.v1.RefactorType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* gooseclip.goosecode.ide.v1.Rename rename */ 5:
                    message.data = {
                        oneofKind: "rename",
                        rename: Rename.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).rename)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefactorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* gooseclip.goosecode.ide.v1.RefactorType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* gooseclip.goosecode.ide.v1.Rename rename = 5; */
        if (message.data.oneofKind === "rename")
            Rename.internalBinaryWrite(message.data.rename, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.RefactorRequest
 */
export const RefactorRequest = new RefactorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RefactorResponse$Type extends MessageType<RefactorResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.RefactorResponse", []);
    }
    create(value?: PartialMessage<RefactorResponse>): RefactorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RefactorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RefactorResponse): RefactorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RefactorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.RefactorResponse
 */
export const RefactorResponse = new RefactorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionControlDetailsRequest$Type extends MessageType<VersionControlDetailsRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.VersionControlDetailsRequest", [
            { no: 1, name: "context", kind: "message", T: () => Context, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<VersionControlDetailsRequest>): VersionControlDetailsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<VersionControlDetailsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VersionControlDetailsRequest): VersionControlDetailsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* gooseclip.goosecode.ide.v1.Context context */ 1:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VersionControlDetailsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* gooseclip.goosecode.ide.v1.Context context = 1; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.VersionControlDetailsRequest
 */
export const VersionControlDetailsRequest = new VersionControlDetailsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionControlDetailsResponse$Type extends MessageType<VersionControlDetailsResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.VersionControlDetailsResponse", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } },
            { no: 2, name: "repository", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } },
            { no: 3, name: "branch", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } },
            { no: 4, name: "commit", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "buf.validate.field": { required: true } } }
        ]);
    }
    create(value?: PartialMessage<VersionControlDetailsResponse>): VersionControlDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.owner = "";
        message.repository = "";
        message.branch = "";
        message.commit = "";
        if (value !== undefined)
            reflectionMergePartial<VersionControlDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VersionControlDetailsResponse): VersionControlDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* string repository */ 2:
                    message.repository = reader.string();
                    break;
                case /* string branch */ 3:
                    message.branch = reader.string();
                    break;
                case /* string commit */ 4:
                    message.commit = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VersionControlDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* string repository = 2; */
        if (message.repository !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.repository);
        /* string branch = 3; */
        if (message.branch !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.branch);
        /* string commit = 4; */
        if (message.commit !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.commit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.VersionControlDetailsResponse
 */
export const VersionControlDetailsResponse = new VersionControlDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LintRequest$Type extends MessageType<LintRequest> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.LintRequest", []);
    }
    create(value?: PartialMessage<LintRequest>): LintRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LintRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LintRequest): LintRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LintRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.LintRequest
 */
export const LintRequest = new LintRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LintResponse$Type extends MessageType<LintResponse> {
    constructor() {
        super("gooseclip.goosecode.ide.v1.LintResponse", []);
    }
    create(value?: PartialMessage<LintResponse>): LintResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<LintResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LintResponse): LintResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LintResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message gooseclip.goosecode.ide.v1.LintResponse
 */
export const LintResponse = new LintResponse$Type();
/**
 * @generated ServiceType for protobuf service gooseclip.goosecode.ide.v1.IDEService
 */
export const IDEService = new ServiceType("gooseclip.goosecode.ide.v1.IDEService", [
    { name: "GetFiles", options: {}, I: GetFilesRequest, O: GetFilesResponse },
    { name: "ListFiles", options: {}, I: ListFilesRequest, O: ListFilesResponse },
    { name: "Select", options: {}, I: SelectRequest, O: SelectResponse },
    { name: "Navigate", options: {}, I: NavigateRequest, O: NavigateResponse },
    { name: "Search", options: {}, I: SearchRequest, O: SearchResponse },
    { name: "Probe", options: {}, I: ProbeRequest, O: ProbeResponse },
    { name: "Refactor", options: {}, I: RefactorRequest, O: RefactorResponse },
    { name: "ResolveSymbol", options: {}, I: ResolveSymbolRequest, O: ResolveSymbolResponse },
    { name: "VersionControlDetails", options: {}, I: VersionControlDetailsRequest, O: VersionControlDetailsResponse },
    { name: "Lint", options: {}, I: LintRequest, O: LintResponse },
    { name: "Push", serverStreaming: true, options: {}, I: PushRequest, O: PushResponse }
]);
